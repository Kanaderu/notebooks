# what do I what to know
#   what is the isi of the output spike rate
#   is there a python priority queue
#   simulations to sweep across the parameters
#   with single neuron, show that the accumulator reduces the snr of a uniform

# weights are 8 bits
# accumulator contains 16 bits
# threshold is 3 bits and specifies which of the top 8 bits triggers acc spike

import numpy as np

class SpikeTrain(object):
    """Container for trains of spikes
    """
    def __init__(self, times, weights):
        self.times = times
        self.weights = weights

class AccumulatorState(object):
    """Container for accumulator state
    """
    def __init__(self, time, state):
        self.time = time
        self.state = state

class Accumulator(object):
    """Represents an accumulator
    Parameters:
        threshold: (int) threshold at which neuron will spike
    """
    def __init__(self, threshold):
        assert type(threshold) in [int, np.int, np.int64]
        self.threshold = threshold

    def accumulate(self, spikes_in):
        """Computes the output spike times of the accumulator
        Inputs:
            spikes_in:
        Outputs:
            spikes_out:
        """
        cur_state = 0
        state = [0]
        time = [0.]
        spike_times = []
        spike_weights = []

        for t, w in zip(spikes_in.times, spikes_in.weights):
            time.append(t)
            state.append(cur_state)
            cur_state += w
            time.append(t)
            state.append(cur_state)

            if cur_state >= self.threshold:
                spike_times.append(t)
                spike_weights.append(1)
                cur_state -= self.threshold
                time.append(t)
                state.append(cur_state)
            elif cur_state <= -self.threshold:
                spike_times.append(t)
                spike_weights.append(-1)
                cur_state += self.threshold
                time.append(t)
                state.append(cur_state)
        spikes_out = SpikeTrain(spike_times, spike_weights)
        state = AccumulatorState(time, state)
        return spikes_out, state

class Neuron(object):
    def __init__(self, spike_rate, weight, T0=None):
        """Generates spike trains
        spike_rate: spike rate of neuron
        weight: decode weight of neuron
        T0: initial spike time
            default uniformly random 
        """
        assert type(weight) in [int, np.int, np.int64]
        assert spike_rate >= 0.
        self.spike_rate = spike_rate
        self.weight = weight
        if spike_rate > 0.:
            self.period = 1./spike_rate
            if T0 == None:
                self.T0 = np.random.uniform(0, self.period)
            else:
                self.T0 = T0

    def generate_spikes(self, T):
        """Generates spikes within a time period T
        """
        if self.spike_rate > 0.:
            nspikes = int(T/self.period)
            times = self.period * np.arange(nspikes) + self.T0
            weights = self.weight * np.ones(nspikes, dtype=int)
        else:
            times = np.array([])
            weights = np.array([], dtype=int)
        spikes = SpikeTrain(times, weights)
        return spikes

class Pool(object):
    """A pool of neurons with an accumulator
    """
    def __init__(self, N, spike_rates, weights, threshold, T0s=None):
        if not hasattr(spike_rates, "__iter__"):
            spike_rates = [spike_rates for n in range(N)]
        if not hasattr(weights, "__iter__"):
            weights = [weights for n in range(N)]
        if not hasattr(T0s, "__iter__"):
            T0s = [T0s for n in range(N)]

        self.neurons = [Neuron(spike_rate, weight, T0)
                        for spike_rate, weight, T0
                        in zip(spike_rates, weights, T0s)
        ]
        self.acc = Accumulator(threshold)

    def gen_nrn_spikes(self, T):
        """Generate spikes from neurons and merge them in a single spike train
        """
        spikes = [neuron.generate_spikes(T) for neuron in self.neurons]
        return spikes

    def merge_spikes(self, spikes_in):
        """Merge spikes from multiple neurons into a single spike train
        """
        spike_times = []
        spike_weights = []
        for spikes in spikes_in:
            spike_times.extend(spikes.times)
            spike_weights.extend(spikes.weights)
        sort_idx = np.argsort(spike_times)
        spikes_out = SpikeTrain(np.array(spike_times)[sort_idx],
                                np.array(spike_weights)[sort_idx])
        return spikes_out

    def gen_acc_spikes(self, spikes_in):
        """Run the accumulator for the spike trains generated by generate_spikes
        """
        spikes_out, acc_state = self.acc.accumulate(spikes_in)
        return spikes_out, acc_state

if __name__ == "__main__":
    N = 2
    rates = [100, 50]
    weights = [1, -2]
    threshold = 1
    T = 1.
    pool = Pool(N, rates, weights, threshold)
    spks_in = pool.gen_nrn_spikes(T)
    spks_out, acc_state = pool.gen_acc_spikes((spks_in))
    print("input, len=%d"%len(spks_in.times))
    print("output, len=%d"%len(spks_out.times))
